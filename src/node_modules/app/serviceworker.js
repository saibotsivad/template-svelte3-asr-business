/*

The service-worker.json file is generated as a final step
of building the webapp. It should contain a list of all
built files (e.g. JS/CSS) and all static assets, such as
the logo images and global CSS file.

This file is heavily inspired by the SvelteJS version:

https://github.com/sveltejs/svelte/blob/master/site/src/service-worker.js

*/
import { cacheableFiles, cacheName, prefetchCacheableUrls } from '../../../public/serviceworker-lists.json'

const cachedFiles = new Set(cacheableFiles)

self.addEventListener('install', event => {
	event.waitUntil(
		caches
			.open(cacheName)
			.then(cache => {
				const promises = prefetchCacheableUrls.map(async urlToPrefetch => {
					const url = new URL(urlToPrefetch)
					// Note: If prefetching during the `install` event, if
					// you need to prefetch a URL that is on a host that
					// does not use CORS, you will need to do like so:
					//
					//     const request = new Request(url, { mode: 'no-cors' })
					//
					// However, the problem with no-cors mode is that
					// all responses from cross-origin hosts will be
					// opaque--you won't know why the failure occurred.
					// See: https://github.com/whatwg/fetch/issues/14
					const request = new Request(url, { mode: 'no-cors' })
					const response = await fetch(request)

					// NOTE: You should probably handle response errors
					// here. If I come up with a good use case and example,
					// I'll add it here, but I don't have one yet.

					return cache.put(urlToPrefetch, response)
				})
				return Promise.all([
					cache.addAll(cacheableFiles),
					...promises
				])
			})
			.then(() => {
				// https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope/skipWaiting
				self.skipWaiting()
			})
	)
})

self.addEventListener('activate', event => {
	event.waitUntil(
		caches.keys().then(async keys => {
			// delete all old caches
			for (const key of keys) {
				if (key !== cacheName) await caches.delete(key)
			}
			// https://developer.mozilla.org/en-US/docs/Web/API/Clients/claim
			self.clients.claim()
		})
	)
})

self.addEventListener('fetch', event => {
	if (event.request.method !== 'GET' || event.request.headers.has('range')) return

	const url = new URL(event.request.url)

	// Don't try to handle non http URIs, e.g. `data:`
	if (!url.protocol.startsWith('http')) return

	// Ignore server requests when developing locally.
	if (url.hostname === 'localhost') return

	// Always serve the static files and generated assets from the cache.
	if (url.host === self.location.host && cachedFiles.has(url.pathname)) {
		event.respondWith(caches.match(event.request))
		return
	}

	// Requests for `*/` should serve the `index.html` file.
	if (url.origin === self.origin && url.pathname.endsWith('/')) {
		event.respondWith(caches.match('/index.html'))
		return
	}

	// TODO what is this about?
	if (event.request.cache === 'only-if-cached') return

	// Note: caching all other requests might be a bad idea, if
	// you have certain data consistency requirements. Depending
	// on your application, you might prefer a cache-first approach,
	// instead of the network-first approach here.
	event.respondWith(
		caches
			.open(`offline${cacheName}`)
			.then(async cache => {
				try {
					const response = await fetch(event.request)
					cache.put(event.request, response.clone())
					return response
				} catch (err) {
					const response = await cache.match(event.request)
					if (response) return response

					throw err
				}
			})
	)
})
